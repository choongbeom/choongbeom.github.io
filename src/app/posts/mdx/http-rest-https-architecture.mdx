---
title: "실무자가 반드시 알아야 할 HTTP·REST·HTTPS 내부 구조 정리"
date: "2025-11-28"
tags: ["CS", "HTTP", "REST", "HTTPS"]
slug: "http-rest-https-architecture"
description: "HTTP, REST, HTTPS의 핵심 구조를 실무자 관점에서 재정리한 글입니다."
---

HTTP와 REST, HTTPS는 거의 모든 웹 서비스의 기반이다. 그러나 실제로는 GET/POST 사용 수준에서 멈추고, 그 내부 동작 원리를 깊게 이해하지 못한 경우가 많다.

이번 글은 **HTTP 기반 API를 설계·개발·운영할 때 실무자가 반드시 이해해야 하는 핵심 개념**을 구조적으로 정리한 내용이다.

정리 범위는 다음과 같다.

1. HTTP: 텍스트 기반 프로토콜의 구조
2. REST: HTTP를 "잘" 쓰기 위한 아키텍처 스타일
3. HTTPS/TLS: HTTP를 안전하게 보호하는 기술



## 1. HTTP – 프로토콜의 구조로 이해하기

### 1-1. HTTP는 OSI 7 Layer 중 어디에 있는가?

HTTP는 OSI 7 Layer의 <b>L7(응용 계층)</b>에 위치하는 텍스트 기반 프로토콜이다. 실제 데이터 전송은 TCP/IP가 담당하고, HTTP는 그 위에서 메시지 형식을 정의한다.

실제 스택 구조는 다음과 같다.

- Application (브라우저, 앱, 서버)
- HTTP
- TLS(HTTPS인 경우)
- TCP
- IP
- Ethernet



### 1-2. HTTP 메시지 구조

HTTP/1.1 요청과 응답 메시지는 다음과 같은 공통 구조를 가진다.

```
Start-Line
Header: value
Header: value

[Body...]
```

#### 요청 예시

```http
GET /articles/10 HTTP/1.1
Host: api.example.com
Accept: application/json
Authorization: Bearer ...
```

#### 응답 예시

```http
HTTP/1.1 201 Created
Content-Type: application/json
Location: /articles/101
```

**주요 상태코드**

- 200 OK
- 201 Created
- 204 No Content
- 304 Not Modified
- 400 Bad Request
- 401 Unauthorized
- 403 Forbidden
- 404 Not Found
- 409 Conflict
- 422 Unprocessable Entity
- 500 Internal Server Error
- 503 Service Unavailable



### 1-3. HTTP/1.1 연결 관리

#### Keep-Alive

HTTP/1.1은 기본적으로 Persistent Connection을 사용하여 하나의 TCP 연결에서 여러 요청을 처리한다.

#### HTTP/2

- Multiplexing
- Header Compression
- Binary Framing

#### HTTP/3 (QUIC 기반)

- UDP 기반
- 전송 계층 HOL Blocking 제거
- TLS 1.3 기본 탑재



### 1-4. Safe / Idempotent

| Method | Safe | Idempotent |
|--------|------|------------|
| GET    | ✔ | ✔ |
| HEAD   | ✔ | ✔ |
| OPTIONS| ✔ | ✔ |
| PUT    | ✘ | ✔ |
| DELETE | ✘ | ✔ |
| POST   | ✘ | ✘ |

**설명**

- Safe: 서버 상태를 변경하지 않음
- Idempotent: 여러 번 호출해도 최종 상태가 동일함



### 1-5. Chunked Transfer Encoding

응답 길이를 미리 알 수 없을 때 사용한다.

```http
HTTP/1.1 200 OK
Transfer-Encoding: chunked

5
Hello
7
World!
0
```



## 2. REST – HTTP를 올바르게 사용하는 아키텍처

REST는 Roy Fielding의 논문에서 정의된 **아키텍처 제약 조건 집합**이다.

핵심 제약:

1. Client–Server
2. Stateless
3. Cacheable
4. Uniform Interface
5. Layered System

실무에서는 특히 **Uniform Interface**와 **Stateless**가 중요하다.



### 2-1. Uniform Interface

1. **리소스 식별**
   - URI는 명사 기반
   - `/users/10`, `/articles/101/comments`

2. **표현을 통한 리소스 조작 (Representation)**
   - JSON 등으로 리소스를 표현하고 이를 수정해 다시 보냄

3. **Self-descriptive Messages**
   - Content-Type, Cache-Control 등 해석에 필요한 정보 포함

4. **HATEOAS**
   - 실무에서는 거의 사용하지 않고 API 문서로 대체



### 2-2. RESTful URI 설계

#### 비RESTful (RPC 스타일)

- `POST /createUser`
- `POST /deleteUser`

#### RESTful

- `POST /users`
- `GET /users/10`
- `PUT /users/10`
- `DELETE /users/10`

#### 필터링·정렬·페이지네이션

```http
GET /articles?authorId=10&tag=network&page=2&size=20
```



### 2-3. 에러 응답 패턴

```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "title은 필수입니다."
  }
}
```



### 2-4. Stateless

- 서버가 클라이언트의 상태를 저장하지 않음
- 요청 하나만으로 처리 가능해야 함
- 서버 확장성이 높아짐



## 3. HTTPS – HTTP를 보호하는 TLS

HTTPS는 **HTTP + TLS** 조합이다.

- `http://` → 평문 전송
- `https://` → TLS Handshake 후 암호화된 HTTP 데이터 전송



### 3-1. 보안의 3요소

1. 기밀성 (암호화)
2. 무결성 (변조 방지)
3. 인증 (서버 신뢰성 검증)



### 3-2. TLS 1.3 Handshake

핵심 절차:

1. ClientHello
2. ServerHello + Certificate
3. 키 합의(ECDHE 기반)
4. 세션 키 생성 → Finished 메시지 교환
5. 이후 모든 HTTP 메시지는 암호화



### 3-3. 비유로 보는 HTTP vs HTTPS

- HTTP: 엽서 (누구나 내용 확인 가능)
- HTTPS: 잠긴 금고 (키 없으면 내용 확인 불가)



## 4. 마무리

HTTP·REST·HTTPS는 웹 서비스의 기본 구조다.  
이 세 가지를 정확히 이해하면 다음과 같은 이점이 있다.

- 올바른 API 설계 가능
- 장애 원인 분석 속도 향상
- 클라이언트·서버 간 인터페이스 명확화
- 보안 이슈 대응 능력 강화

기본이지만 가장 중요한 영역이며, 실무에서 반드시 한 번은 정리해 둘 가치가 있다.

## **전체 문서 보기**  
- [실무자가 반드시 알아야 할 HTTP·REST·HTTPS 기술 구조와 내부 동작 원리.pdf (ver.2025.11.28)](/assets/docs/실무자가-반드시-알아야-할-HTTP·REST·HTTPS-기술-구조와-내부-동작-원리.pdf)
